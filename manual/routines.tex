
\module{PGADVANCE -- non-standard alias for PGPAGE}
{\eightpoint\begintt
      SUBROUTINE PGADVANCE
\endtt}

\module{PGASK -- control new page prompting}
{\eightpoint\begintt
      SUBROUTINE PGASK (FLAG)
      LOGICAL FLAG
 
Change the "prompt state" of PGPLOT. If the prompt state is
ON, PGPAGE will type "Type <RETURN> for next page:" and will wait
for the user to type <CR> before starting a new page.  The initial
prompt state (after a call to PGBEG) is ON for interactive devices.
Prompt state is always OFF for non-interactive devices.
 
Arguments:
 FLAG   (input)  : if .TRUE., and if the device is an interactive
                   device, the prompt state will be set to ON. If
                   .FALSE., the prompt state will be set to OFF.
\endtt}

\module{PGBBUF -- begin batch of output (buffer)}
{\eightpoint\begintt
      SUBROUTINE PGBBUF
 
Begin saving graphical output commands in an internal buffer; the
commands are held until a matching PGEBUF call (or until the buffer
is emptied by PGUPDT). This can greatly improve the efficiency of
PGPLOT.  PGBBUF increments an internal counter, while PGEBUF
decrements this counter and flushes the buffer to the output
device when the counter drops to zero.  PGBBUF and PGEBUF calls
should always be paired.
 
Arguments: none
\endtt}

\module{PGBEG -- begin PGPLOT, open output device}
{\eightpoint\begintt
      INTEGER FUNCTION PGBEG (UNIT, FILE, NXSUB, NYSUB)
      INTEGER       UNIT
      CHARACTER*(*) FILE
      INTEGER       NXSUB, NYSUB
 
Begin PGPLOT, open the plot file.  A call to PGBEG is
required before any other calls to PGPLOT subroutines.  If a plot
file is already open for PGPLOT output, it is closed before the new
file is opened.
 
Returns:
 PGBEG         : a status return value. A value of 1 indicates
                   successful completion, any other value indicates
                   an error. In the event of error a message is
                   written on the standard error unit.  
                   To test the return value, call
                   PGBEG as a function, eg IER=PGBEG(...); note
                   that PGBEG must be declared INTEGER in the
                   calling program.
Arguments:
 UNIT  (input)   : this argument is ignored by PGBEG (use zero).
 FILE  (input)   : the "device specification" for the plot device.
                   Device specifications are installation dependent,
                   but usually have the form "device/type" or
                   "file/type". If this argument is a
                   question mark ('?'), PGBEG will prompt the user
                   to supply a string.
 NXSUB  (input)  : the number of subdivisions of the view surface in
                   X.
 NYSUB  (input)  : the number of subdivisions of the view surface in
                   Y. PGPLOT puts NXSUB x NYSUB graphs on each plot
                   page or screen; when the view surface is sub-
                   divided in this way, PGPAGE moves to the next
                   sub-page, not the  next physical page.
\endtt}

\module{PGBEGIN -- non-standard alias for PGBEG}
{\eightpoint\begintt
      INTEGER FUNCTION PGBEGIN (UNIT, FILE, NXSUB, NYSUB)
      INTEGER       UNIT
      CHARACTER*(*) FILE
      INTEGER       NXSUB, NYSUB   
\endtt}

\module{PGBIN -- histogram of binned data}
{\eightpoint\begintt
      SUBROUTINE PGBIN (NBIN, X, DATA, CENTER)
      INTEGER NBIN
      REAL X(*), DATA(*)
      LOGICAL CENTER
 
Plot a histogram of NBIN values with X(1..NBIN) values along
the ordinate, and DATA(1...NBIN) along the abscissa. Bin width is
spacing between X values.
 
Arguments:
 NBIN   (input)  : number of values.
 X      (input)  : abscissae of bins.
 DATA   (input)  : data values of bins.
 CENTER (input)  : if .TRUE., the X values denote the center of the
                   bin; if .FALSE., the X values denote the lower
                   edge (in X) of the bin.
\endtt}

\module{PGBOX -- draw labeled frame around viewport}
{\eightpoint\begintt
      SUBROUTINE PGBOX (XOPT, XTICK, NXSUB, YOPT, YTICK, NYSUB)
      CHARACTER*(*) XOPT, YOPT
      REAL XTICK, YTICK
      INTEGER NXSUB, NYSUB
 
Annotate the viewport with frame, axes, numeric labels, etc.
PGBOX is called by on the user's behalf by PGENV, but may also be
called explicitly.
 
Arguments:
 XOPT   (input)  : string of options for X (horizontal) axis of
                   plot. Options are single letters, and may be in
                   any order (see below).
 XTICK  (input)  : world coordinate interval between major tick marks
                   on X axis. If XTICK=0.0, the interval is chosen by
                   PGBOX, so that there will be at least 3 major tick
                   marks along the axis.
 NXSUB  (input)  : the number of subintervals to divide the major
                   coordinate interval into. If XTICK=0.0 or NXSUB=0,
                   the number is chosen by PGBOX.
 YOPT   (input)  : string of options for Y (vertical) axis of plot.
                   Coding is the same as for XOPT.
 YTICK  (input)  : like XTICK for the Y axis.
 NYSUB  (input)  : like NXSUB for the Y axis.
 
Options (for parameters XOPT and YOPT):
 A : draw Axis (X axis is horizontal line Y=0, Y axis is vertical
     line X=0).
 B : draw bottom (X) or left (Y) edge of frame.
 C : draw top (X) or right (Y) edge of frame.
 G : draw Grid of vertical (X) or horizontal (Y) lines.
 I : Invert the tick marks; ie draw them outside the viewport
     instead of inside.
 L : label axis Logarithmically (see below).
 N : write Numeric labels in the conventional location below the
     viewport (X) or to the left of the viewport (Y).
 P : extend ("Project") major tick marks outside the box (ignored if
     option I is specified).
 M : write numeric labels in the unconventional location above the
     viewport (X) or to the right of the viewport (Y).
 T : draw major Tick marks at the major coordinate interval.
 S : draw minor tick marks (Subticks).
 V : orient numeric labels Vertically. This is only applicable to Y.
     The default is to write Y-labels parallel to the axis
 
To get a complete frame, specify BC in both XOPT and YOPT.
Tick marks, if requested, are drawn on the axes or frame
or both, depending which are requested. If none of ABC is specified,
tick marks will not be drawn. When PGENV calls PGBOX, it sets both
XOPT and YOPT according to the value of its parameter AXIS:
-1: 'BC', 0: 'BCNST', 1: 'ABCNST', 2: 'ABCGNST'.
 
For a logarithmic axis, the major tick interval is always 1.0. The
numeric label is 10**(x) where x is the world coordinate at the
tick mark. If subticks are requested, 8 subticks are drawn between
each major tick at equal logarithmic intervals.
\endtt}

\module{PGCONB -- contour map of a 2D data array, with blanking}
{\eightpoint\begintt
      SUBROUTINE PGCONB (A, IDIM, JDIM, I1, I2, J1, J2, C, NC, TR, 
     1                   BLANK)
      INTEGER IDIM, JDIM, I1, I2, J1, J2, NC
      REAL    A(IDIM,JDIM), C(*), TR(6), BLANK
 
Draw a contour map of an array. This routine is the same as PGCONS,
except that array elements that have the "magic value" defined by
argument BLANK are ignored, making gaps in the contour map. The
routine may be useful for data measured on most but not all of the
points of a grid.
 
Arguments:
 A      (input)  : data array.
 IDIM   (input)  : first dimension of A.
 JDIM   (input)  : second dimension of A.
 I1,I2  (input)  : range of first index to be contoured (inclusive).
 J1,J2  (input)  : range of second index to be contoured (inclusive).
 C      (input)  : array of contour levels (in the same units as the
                   data in array A); dimension at least NC.
 NC     (input)  : number of contour levels (less than or equal to
                   dimension of C). The absolute value of this
                   argument is used (for compatibility with PGCONT,
                   where the sign of NC is significant).
 TR     (input)  : array defining a transformation between the I,J
                   grid of the array and the world coordinates. The
                   world coordinates of the array point A(I,J) are
                   given by:
                     X = TR(1) + TR(2)*I + TR(3)*J
                     Y = TR(4) + TR(5)*I + TR(6)*J
                   Usually TR(3) and TR(5) are zero - unless the
                   coordinate transformation involves a rotation
                   or shear.
 BLANK   (input) : elements of array A that are exactly equal to
                   this value are ignored (blanked).
\endtt}

\module{PGCONS -- contour map of a 2D data array (fast algorithm)}
{\eightpoint\begintt
      SUBROUTINE PGCONS (A, IDIM, JDIM, I1, I2, J1, J2, C, NC, TR)
      INTEGER IDIM, JDIM, I1, I2, J1, J2, NC
      REAL    A(IDIM,JDIM), C(*), TR(6)
 
Draw a contour map of an array. The map is truncated if
necessary at the boundaries of the viewport.  Each contour line is
drawn with the current line attributes (color index, style, and
width).  This routine, unlike PGCONT, does not draw each contour as a
continuous line, but draws the straight line segments composing each
contour in a random order.  It is thus not suitable for use on pen
plotters, and it usually gives unsatisfactory results with dashed or
dotted lines.  It is, however, faster than PGCONT, especially if
several contour levels are drawn with one call of PGCONS.
 
Arguments:
 A      (input)  : data array.
 IDIM   (input)  : first dimension of A.
 JDIM   (input)  : second dimension of A.
 I1,I2  (input)  : range of first index to be contoured (inclusive).
 J1,J2  (input)  : range of second index to be contoured (inclusive).
 C      (input)  : array of contour levels (in the same units as the
                   data in array A); dimension at least NC.
 NC     (input)  : number of contour levels (less than or equal to
                   dimension of C). The absolute value of this
                   argument is used (for compatibility with PGCONT,
                   where the sign of NC is significant).
 TR     (input)  : array defining a transformation between the I,J
                   grid of the array and the world coordinates. The
                   world coordinates of the array point A(I,J) are
                   given by:
                     X = TR(1) + TR(2)*I + TR(3)*J
                     Y = TR(4) + TR(5)*I + TR(6)*J
                   Usually TR(3) and TR(5) are zero - unless the
                   coordinate transformation involves a rotation
                   or shear.
\endtt}

\module{PGCONT -- contour map of a 2D data array (contour-following)}
{\eightpoint\begintt
      SUBROUTINE PGCONT (A, IDIM, JDIM, I1, I2, J1, J2, C, NC, TR)
      INTEGER IDIM, JDIM, I1, J1, I2, J2, NC
      REAL A(IDIM,JDIM), C(*), TR(6)
 
Draw a contour map of an array.  The map is truncated if
necessary at the boundaries of the viewport.  Each contour line
is drawn with the current line attributes (color index, style, and
width); except that if argument NC is positive (see below), the line
style is set by PGCONT to 1 (solid) for positive contours or 2
(dashed) for negative contours.
 
Arguments:
 A      (input) : data array.
 IDIM   (input) : first dimension of A.
 JDIM   (input) : second dimension of A.
 I1, I2 (input) : range of first index to be contoured (inclusive).
 J1, J2 (input) : range of second index to be contoured (inclusive).
 C      (input) : array of NC contour levels; dimension at least NC.
 NC     (input) : +/- number of contour levels (less than or equal
                  to dimension of C). If NC is positive, it is the
                  number of contour levels, and the line-style is
                  chosen automatically as described above. If NC is
                  negative, it is minus the number of contour
                  levels, and the current setting of line-style is
                  used for all the contours.
 TR     (input) : array defining a transformation between the I,J
                  grid of the array and the world coordinates.
                  The world coordinates of the array point A(I,J)
                  are given by:
                    X = TR(1) + TR(2)*I + TR(3)*J
                    Y = TR(4) + TR(5)*I + TR(6)*J
                  Usually TR(3) and TR(5) are zero - unless the
                  coordinate transformation involves a rotation or
                  shear.
\endtt}

\module{PGCONX -- contour map of a 2D data array (non-rectangular)}
{\eightpoint\begintt
      SUBROUTINE PGCONX (A, IDIM, JDIM, I1, I2, J1, J2, C, NC, PLOT)
      INTEGER  IDIM, JDIM, I1, J1, I2, J2, NC
      REAL     A(IDIM,JDIM), C(*)
      EXTERNAL PLOT
 
Draw a contour map of an array using a user-supplied plotting
routine.  This routine should be used instead of PGCONT when the
data are defined on a non-rectangular grid.  PGCONT permits only
a linear transformation between the (I,J) grid of the array
and the world coordinate system (x,y), but PGCONX permits any
transformation to be used, the transformation being defined by a
user-supplied subroutine. The nature of the contouring algorithm,
however, dictates that the transformation should maintain the
rectangular topology of the grid, although grid-points may be
allowed to coalesce.  As an example of a deformed rectangular
grid, consider data given on the polar grid theta=0.1n(pi/2),
for n=0,1,...,10, and r=0.25m, for m=0,1,..,4. This grid
contains 55 points, of which 11 are coincident at the origin.
The input array for PGCONX should be dimensioned (11,5), and
data values should be provided for all 55 elements.  PGCONX can
also be used for special applications in which the height of the
contour affects its appearance, e.g., stereoscopic views.
 
The map is truncated if necessary at the boundaries of the viewport.
Each contour line is drawn with the current line attributes (color
index, style, and width); except that if argument NC is positive
(see below), the line style is set by PGCONX to 1 (solid) for
positive contours or 2 (dashed) for negative contours. Attributes
for the contour lines can also be set in the user-supplied
subroutine, if desired.
 
Arguments:
 A      (input) : data array.
 IDIM   (input) : first dimension of A.
 JDIM   (input) : second dimension of A.
 I1, I2 (input) : range of first index to be contoured (inclusive).
 J1, J2 (input) : range of second index to be contoured (inclusive).
 C      (input) : array of NC contour levels; dimension at least NC.
 NC     (input) : +/- number of contour levels (less than or equal
                  to dimension of C). If NC is positive, it is the
                  number of contour levels, and the line-style is
                  chosen automatically as described above. If NC is
                  negative, it is minus the number of contour
                  levels, and the current setting of line-style is
                  used for all the contours.
 PLOT   (input) : the address (name) of a subroutine supplied by
                  the user, which will be called by PGCONX to do
                  the actual plotting. This must be declared
                  EXTERNAL in the program unit calling PGCONX.
 
The subroutine PLOT will be called with four arguments:
     CALL PLOT(VISBLE,X,Y,Z)
where X,Y (input) are real variables corresponding to
I,J indices of the array A. If  VISBLE (input, integer) is 1,
PLOT should draw a visible line from the current pen
position to the world coordinate point corresponding to (X,Y);
if it is 0, it should move the pen to (X,Y). Z is the value
of the current contour level, and may be used by PLOT if desired.
Example:
      SUBROUTINE PLOT (VISBLE,X,Y,Z)
      REAL X, Y, Z, XWORLD, YWORLD
      INTEGER VISBLE
      XWORLD = X*COS(Y) ! this is the user-defined
      YWORLD = X*SIN(Y) ! transformation
      IF (VISBLE.EQ.0) THEN
          CALL PGMOVE (XWORLD, YWORLD)
      ELSE
          CALL PGDRAW (XWORLD, YWORLD)
      END IF
      END
\endtt}

\module{PGCURS -- read cursor position}
{\eightpoint\begintt
      INTEGER FUNCTION PGCURS (X, Y, CH)
      REAL X, Y
      CHARACTER*1 CH
 
Read the cursor position and a character typed by the user.
The position is returned in world coordinates.  PGCURS positions
the cursor at the position specified, allows the user to move the
cursor using the joystick or arrow keys or whatever is available on
the device. When he has positioned the cursor, the user types a
single character on the keyboard; PGCURS then returns this
character and the new cursor position (in world coordinates).
 
Returns:
 PGCURS         : 1 if the call was successful; 0 if the device
                   has no cursor or some other error occurs.
Arguments:
 X      (in/out) : the world x-coordinate of the cursor.
 Y      (in/out) : the world y-coordinate of the cursor.
 CH     (output) : the character typed by the user; if the device has
                   no cursor or if some other error occurs, the value
                   CHAR(0) [ASCII NUL character] is returned.
 
Note: The cursor coordinates (X,Y) may be changed by PGCURS even if
the device has no cursor or if the user does not move the cursor.
Under these circumstances, the position returned in (X,Y) is that of
the pixel nearest to the requested position.
\endtt}

\module{PGCURSE -- non-standard alias for PGCURS}
{\eightpoint\begintt
      INTEGER FUNCTION PGCURSE (X, Y, CH)
      REAL X, Y
      CHARACTER*1 CH
\endtt}

\module{PGDRAW -- draw a line from the current pen position to a point}
{\eightpoint\begintt
      SUBROUTINE PGDRAW (X, Y)
      REAL X, Y
 
Draw a line from the current pen position to the point
with world-coordinates (X,Y). The line is clipped at the edge of the
current window. The new pen position is (X,Y) in world coordinates.
 
Arguments:
 X      (input)  : world x-coordinate of the end point of the line.
 Y      (input)  : world y-coordinate of the end point of the line.
\endtt}

\module{PGEBUF -- end batch of output (buffer)}
{\eightpoint\begintt
      SUBROUTINE PGEBUF
 
A call to PGEBUF marks the end of a batch of graphical output begun
with the last call of PGBBUF.  PGBBUF and PGEBUF calls should always
be paired. Each call to PGBBUF increments a counter, while each call
to PGEBUF decrements the counter. When the counter reaches 0, the
batch of output is written on the output device.
 
Arguments: none
\endtt}

\module{PGEND -- terminate PGPLOT}
{\eightpoint\begintt
      SUBROUTINE PGEND
 
Terminate PGPLOT, close the plot file, release the graphics
device.  If the call to PGEND is omitted, some or all of the plot
may be lost. If the environment parameter PGPLOT_IDENT is defined 
(with any value), and the device is a hardcopy device, an
identifying label is written on the plot (by calling PGIDEN: q.v.).
 
Arguments: none
\endtt}

\module{PGENV -- set window and viewport and draw labeled frame}
{\eightpoint\begintt
      SUBROUTINE PGENV (XMIN, XMAX, YMIN, YMAX, JUST, AXIS)
      REAL XMIN, XMAX, YMIN, YMAX
      INTEGER JUST, AXIS
 
Set PGPLOT "Plotter Environment".  PGENV establishes the scaling
for subsequent calls to PGPT, PGLINE, etc.  The plotter is
advanced to a new (sub-)page, clearing the screen if necessary.
If the "prompt state" is ON (see PGASK), confirmation
is requested from the user before clearing the screen.
If requested, a box, axes, labels, etc. are drawn according to
the setting of argument AXIS.
 
Arguments:
 XMIN   (input)  : the world x-coordinate at the bottom left corner
                   of the viewport.
 XMAX   (input)  : the world x-coordinate at the top right corner
                   of the viewport (note XMAX may be less than XMIN).
 YMIN   (input)  : the world y-coordinate at the bottom left corner
                   of the viewport.
 YMAX   (input)  : the world y-coordinate at the top right corner
                   of the viewport (note YMAX may be less than YMIN).
 JUST   (input)  : if JUST=1, the scales of the x and y axes (in
                   world coordinates per inch) will be equal,
                   otherwise they will be scaled independently.
 AXIS   (input)  : controls the plotting of axes, tick marks, etc:
     AXIS = -2 : draw no box, axes or labels;
     AXIS = -1 : draw box only;
     AXIS =  0 : draw box and label it with coordinates;
     AXIS =  1 : same as AXIS=0, but also draw the
                 coordinate axes (X=0, Y=0);
     AXIS =  2 : same as AXIS=1, but also draw grid lines
                 at major increments of the coordinates;
     AXIS = 10 : draw box and label X-axis logarithmically;
     AXIS = 20 : draw box and label Y-axis logarithmically;
     AXIS = 30 : draw box and label both axes logarithmically.
 
For other axis options, use routine PGBOX. PGENV can be pursuaded to
call PGBOX with additional axis options by defining an environment
parameter PGPLOT_ENVOPT containing the required option codes. 
Examples:
  PGPLOT_ENVOPT=P      ! draw Projecting tick marks
  PGPLOT_ENVOPT=I      ! Invert the tick marks
  PGPLOT_ENVOPT=IV     ! Invert tick marks and label y Vertically
\endtt}

\module{PGERRB -- horizontal error bar}
{\eightpoint\begintt
      SUBROUTINE PGERRB (DIR, N, X, Y, E, T)
      INTEGER DIR, N
      REAL X(*), Y(*), E(*)
      REAL T
 
Plot error bars in the direction specified by DIR.
This routine draws an error bar only; to mark the data point at
the start of the error bar, an additional call to PGPT is required.
 
Arguments:
 DIR    (input)  : direction to plot the error bar relative to
                   the data point.  DIR is 1 for +X; 2 for +Y;
                   3 for -X; and 4 for -Y;
 N      (input)  : number of error bars to plot.
 X      (input)  : world x-coordinates of the data.
 Y      (input)  : world y-coordinates of the data.
 E      (input)  : value of error bar distance to be added to the
                   data position in world coordinates.
 T      (input)  : length of terminals to be drawn at the ends
                   of the error bar, as a multiple of the default
                   length; if T = 0.0, no terminals will be drawn.
 
Note: the dimension of arrays X, Y, and E must be greater
than or equal to N. If N is 1, X, Y, and E may be scalar
variables, or expressions.
\endtt}

\module{PGERRX -- horizontal error bar}
{\eightpoint\begintt
      SUBROUTINE PGERRX (N, X1, X2, Y, T)
      INTEGER N
      REAL X1(*), X2(*), Y(*)
      REAL T
 
Plot horizontal error bars.
This routine draws an error bar only; to mark the data point in
the middle of the error bar, an additional call to PGPT or
PGERRY is required.
 
Arguments:
 N      (input)  : number of error bars to plot.
 X1     (input)  : world x-coordinates of lower end of the
                   error bars.
 X2     (input)  : world x-coordinates of upper end of the
                   error bars.
 Y      (input)  : world y-coordinates of the data.
 T      (input)  : length of terminals to be drawn at the ends
                   of the error bar, as a multiple of the default
                   length; if T = 0.0, no terminals will be drawn.
 
Note: the dimension of arrays X1, X2, and Y must be greater
than or equal to N. If N is 1, X1, X2, and Y may be scalar
variables, or expressions, eg:
      CALL PGERRX(1,X-SIGMA,X+SIGMA,Y)
\endtt}

\module{PGERRY -- vertical error bar}
{\eightpoint\begintt
      SUBROUTINE PGERRY (N, X, Y1, Y2, T)
 
Plot vertical error bars.
This routine draws an error bar only; to mark the data point in
the middle of the error bar, an additional call to PGPT or
PGERRX is required.
 
Arguments:
 N      (input)  : number of error bars to plot.
 X      (input)  : world x-coordinates of the data.
 Y1     (input)  : world y-coordinates of top end of the
                   error bars.
 Y2     (input)  : world y-coordinates of bottom end of the
                   error bars.
 T      (input)  : length of terminals to be drawn at the ends
                   of the error bar, as a multiple of the default
                   length; if T = 0.0, no terminals will be drawn.
 
Note: the dimension of arrays X, Y1, and Y2 must be greater
than or equal to N. If N is 1, X, Y1, and Y2 may be scalar
variables or expressions, eg:
      CALL PGERRY(1,X,Y+SIGMA,Y-SIGMA)
\endtt}

\module{PGETXT -- erase text from graphics display}
{\eightpoint\begintt
      SUBROUTINE PGETXT
 
Some graphics terminals display text (the normal interactive dialog)
on the same screen as graphics. This routine erases the text from the
view surface without affecting the graphics. It does nothing on
devices which do not display text on the graphics screen, and on
devices which do not have this capability.
 
Arguments:
 None
\endtt}

\module{PGFUNT -- function defined by X = F(T), Y = G(T)}
{\eightpoint\begintt
      SUBROUTINE PGFUNT (FX, FY, N, TMIN, TMAX, PGFLAG)
      REAL FX, FY
      INTEGER N
      REAL TMIN, TMAX
      INTEGER PGFLAG
 
Draw a curve defined by parametric equations X = FX(T), Y = FY(T).
 
Arguments:
 FX     (external real function): supplied by the user, evaluates
                   X-coordinate.
 FY     (external real function): supplied by the user, evaluates
                   Y-coordinate.
 N      (input)  : the number of points required to define the
                   curve. The functions FX and FY will each be
                   called N+1 times.
 TMIN   (input)  : the minimum value for the parameter T.
 TMAX   (input)  : the maximum value for the parameter T.
 PGFLAG (input)  : if PGFLAG = 1, the curve is plotted in the
                   current window and viewport; if PGFLAG = 0,
                   PGENV is called automatically by PGFUNT to
                   start a new plot with automatic scaling.
 
Note: The functions FX and FY must be declared EXTERNAL in the
Fortran program unit that calls PGFUNT.
\endtt}

\module{PGFUNX -- function defined by Y = F(X)}
{\eightpoint\begintt
      SUBROUTINE PGFUNX (FY, N, XMIN, XMAX, PGFLAG)
      REAL FY
      INTEGER N
      REAL XMIN, XMAX
      INTEGER PGFLAG
 
Draw a curve defined by the equation Y = FY(X), where FY is a
user-supplied subroutine.
 
Arguments:
 FY     (external real function): supplied by the user, evaluates
                   Y value at a given X-coordinate.
 N      (input)  : the number of points required to define the
                   curve. The function FY will be called N+1 times.
                   If PGFLAG=0 and N is greater than 1000, 1000
                   will be used instead.  If N is less than 1,
                   nothing will be drawn.
 XMIN   (input)  : the minimum value of X.
 XMAX   (input)  : the maximum value of X.
 PGFLAG (input)  : if PGFLAG = 1, the curve is plotted in the
                   current window and viewport; if PGFLAG = 0,
                   PGENV is called automatically by PGFUNX to
                   start a new plot with X limits (XMIN, XMAX)
                   and automatic scaling in Y.
 
Note: The function FY must be declared EXTERNAL in the Fortran
program unit that calls PGFUNX.  It has one argument, the
x-coordinate at which the y value is required, e.g.
  REAL FUNCTION FY(X)
  REAL X
  FY = .....
  END
\endtt}

\module{PGFUNY -- function defined by X = F(Y)}
{\eightpoint\begintt
      SUBROUTINE PGFUNY (FX, N, YMIN, YMAX, PGFLAG)
      REAL    FX
      INTEGER N
      REAL    YMIN, YMAX
      INTEGER PGFLAG
 
Draw a curve defined by the equation X = FX(Y), where FY is a
user-supplied subroutine.
 
Arguments:
 FX     (external real function): supplied by the user, evaluates
                   X value at a given Y-coordinate.
 N      (input)  : the number of points required to define the
                   curve. The function FX will be called N+1 times.
                   If PGFLAG=0 and N is greater than 1000, 1000
                   will be used instead.  If N is less than 1,
                   nothing will be drawn.
 YMIN   (input)  : the minimum value of Y.
 YMAX   (input)  : the maximum value of Y.
 PGFLAG (input)  : if PGFLAG = 1, the curve is plotted in the
                   current window and viewport; if PGFLAG = 0,
                   PGENV is called automatically by PGFUNY to
                   start a new plot with Y limits (YMIN, YMAX)
                   and automatic scaling in X.
 
Note: The function FX must be declared EXTERNAL in the Fortran
program unit that calls PGFUNY.  It has one argument, the
y-coordinate at which the x value is required, e.g.
  REAL FUNCTION FX(Y)
  REAL Y
  FX = .....
  END
\endtt}

\module{PGGRAY -- gray-scale map of a 2D data array}
{\eightpoint\begintt
      SUBROUTINE PGGRAY (A, IDIM, JDIM, I1, I2, J1, J2,
     1                   FG, BG, TR)
      INTEGER IDIM, JDIM, I1, I2, J1, J2
      REAL    A(IDIM,JDIM)
      REAL    FG, BG
      REAL TR(6)
 
Draw gray-scale map of an array in current window. The subsection
of the array A defined by indices (I1:I2, J1:J2) is mapped onto
the view surface world-coordinate system by the transformation
matrix TR. The resulting quadrilateral region is clipped at the edge
of the window and shaded with the shade at each point determined
by the corresponding array value.  The shade is a number in the
range 0 to 1 obtained by linear interpolation between the background
level (BG) and the foreground level (FG), i.e.,
 
  shade = [A(i,j) - BG] / [FG - BG]
 
The background level BG can be either less than or greater than the
foreground level FG.  Points in the array that are outside the range
BG to FG are assigned shade 0 or 1 as appropriate.
 
The algorithm used by PGGRAY is device-dependent.  On devices
that have only two color indices (0 and 1), the background color
is the color assigned to color index 0, the foreground color
is the color assigned to color index 1, and PGGRAY uses a
"dithering" algorithm to fill in pixels in the two colors, with
the shade (computed as above) determining the faction of pixels
that are assigned color index 1.
 
On devices that have more than 16 color indices, PGGRAY may use
color indices outside the range 0-15 to provide more than two
gray shades.  Note that PGGRAY may change the color representation
of these color indices, but it will not change the representation
of indices 0-15.
 
On most devices, the shaded region is "opaque", i.e., it obscures
all graphical elements previously drawn in the region. But on
devices that do not have erase capability, the background shade
is "transparent" and allows previously-drawn graphics to show
through.
 
The transformation matrix TR is used to calculate the world
coordinates of the center of the "cell" that represents each
array element. The world coordinates of the center of the cell
corresponding to array element A(I,J) are given by:
 
         X = TR(1) + TR(2)*I + TR(3)*J
         Y = TR(4) + TR(5)*I + TR(6)*J
 
Usually TR(3) and TR(5) are zero -- unless the coordinate
transformation involves a rotation or shear.  The corners of the
quadrilateral region that is shaded by PGGRAY are given by
applying this transformation to (I1-0.5,J1-0.5), (I2+0.5, J2+0.5).
 
Arguments:
 A      (input)  : the array to be plotted.
 IDIM   (input)  : the first dimension of array A.
 JDIM   (input)  : the second dimension of array A.
 I1, I2 (input)  : the inclusive range of the first index
                   (I) to be plotted.
 J1, J2 (input)  : the inclusive range of the second
                   index (J) to be plotted.
 FG     (input)  : the array value which is to appear with shade
                   1 ("foreground").
 BG     (input)  : the array value which is to appear with shade
                   0 ("background").
 TR     (input)  : transformation matrix between array grid and
                   world coordinates.
\endtt}

\module{PGHI2D -- cross-sections through a 2D data array}
{\eightpoint\begintt
      SUBROUTINE PGHI2D (DATA, NXV, NYV, IX1, IX2, IY1, IY2, X, IOFF,
     1                   BIAS, CENTER, YLIMS)
      INTEGER NXV, NYV, IX1, IX2, IY1, IY2
      REAL    DATA(NXV,NYV)
      REAL    X(IX2-IX1+1), YLIMS(IX2-IX1+1)
      INTEGER IOFF
      REAL    BIAS
      LOGICAL CENTER
 
Plot a series of cross-sections through a 2D data array.
Each cross-section is plotted as a hidden line histogram.  The plot
can be slanted to give a pseudo-3D effect - if this is done, the
call to PGENV may have to be changed to allow for the increased X
range that will be needed.
 
Arguments:
 DATA   (input)  : the data array to be plotted.
 NXV    (input)  : the first dimension of DATA.
 NYV    (input)  : the second dimension of DATA.
 IX1    (input)
 IX2    (input)
 IY1    (input)
 IY2    (input)  : PGHI2D plots a subset of the input array DATA.
                   This subset is delimited in the first (x)
                   dimension by IX1 and IX2 and the 2nd (y) by IY1
                   and IY2, inclusively. Note: IY2 < IY1 is
                   permitted, resulting in a plot with the
                   cross-sections plotted in reverse Y order.
                   However, IX2 must be => IX1.
 X      (input)  : the abscissae of the bins to be plotted. That is,
                   X(1) should be the X value for DATA(IX1,IY1), and
                   X should have (IX2-IX1+1) elements.  The program
                   has to assume that the X value for DATA(x,y) is
                   the same for all y.
 IOFF   (input)  : an offset in array elements applied to successive
                   cross-sections to produce a slanted effect.  A
                   plot with IOFF > 0 slants to the right, one with
                   IOFF < 0 slants left.
 BIAS   (input)  : a bias value applied to each successive cross-
                   section in order to raise it above the previous
                   cross-section.  This is in the same units as the
                   data.
 CENTER (input)  : if .true., the X values denote the center of the
                   bins; if .false. the X values denote the lower
                   edges (in X) of the bins.
 YLIMS  (input)  : workspace.  Should be an array of at least
                   (IX2-IX1+1) elements.
\endtt}

\module{PGHIST -- histogram of unbinned data}
{\eightpoint\begintt
      SUBROUTINE PGHIST (N, DATA, DATMIN, DATMAX, NBIN, PGFLAG)
      INTEGER N
      REAL    DATA(*)
      REAL    DATMIN, DATMAX
      INTEGER NBIN, PGFLAG
 
Draw a histogram of N values of a variable in array
DATA(1...N) in the range DATMIN to DATMAX using NBIN bins.  Note
that array elements which fall exactly on the boundary between
two bins will be counted in the higher bin rather than the
lower one; and array elements whose value is less than DATMIN or
greater than or equal to DATMAX will not be counted at all.
 
Arguments:
 N      (input)  : the number of data values.
 DATA   (input)  : the data values. Note: the dimension of array
                   DATA must be greater than or equal to N. The
                   first N elements of the array are used.
 DATMIN (input)  : the minimum data value for the histogram.
 DATMAX (input)  : the maximum data value for the histogram.
 NBIN   (input)  : the number of bins to use: the range DATMIN to
                   DATMAX is divided into NBIN equal bins and
                   the number of DATA values in each bin is
                   determined by PGHIST.  NBIN may not exceed 200.
 PGFLAG (input)  : if PGFLAG = 1, the histogram is plotted in the
                   current window and viewport; if PGFLAG = 0,
                   PGENV is called automatically by PGHIST to start
                   a new plot (the x-limits of the window will be
                   DATMIN and DATMAX; the y-limits will be chosen
                   automatically.
\endtt}

\module{PGIDEN -- write username, date, and time at bottom of plot}
{\eightpoint\begintt
      SUBROUTINE PGIDEN
 
Write username, date, and time at bottom of plot.
 
Arguments: none.
\endtt}

\module{PGLAB -- write labels for x-axis, y-axis, and top of plot}
{\eightpoint\begintt
      SUBROUTINE PGLAB (XLBL, YLBL, TOPLBL)
      CHARACTER*(*) XLBL, YLBL, TOPLBL
 
Write labels outside the viewport. This routine is a simple
interface to PGMTXT, which should be used if PGLAB is inadequate.
 
Arguments:
 XLBL   (input) : a label for the x-axis (centered below the
                  viewport).
 YLBL   (input) : a label for the y-axis (centered to the left
                  of the viewport, drawn vertically).
 TOPLBL (input) : a label for the entire plot (centered above the
                  viewport).
\endtt}

\module{PGLABEL -- non-standard alias for PGLAB}
{\eightpoint\begintt
      SUBROUTINE PGLABEL (XLBL, YLBL, TOPLBL)
      CHARACTER*(*) XLBL, YLBL, TOPLBL
\endtt}

\module{PGLCUR -- draw a line using the cursor}
{\eightpoint\begintt
      SUBROUTINE PGLCUR (MAXPT, NPT, X, Y)
      INTEGER MAXPT, NPT
      REAL    X(*), Y(*)
 
Interactive routine for user to enter a polyline by use of
the cursor.  Routine allows user to Add and Delete vertices;
vertices are joined by straight-line segments.
 
Arguments:
 MAXPT  (input)  : maximum number of points that may be accepted.
 NPT    (in/out) : number of points entered; should be zero on
                   first call.
 X      (in/out) : array of x-coordinates (dimension at least MAXPT).
 Y      (in/out) : array of y-coordinates (dimension at least MAXPT).
 
Notes:
 
(1) On return from the program, cursor points are returned in
the order they were entered. Routine may be (re-)called with points
already defined in X,Y (# in NPT), and they will be plotted
first, before editing.
 
(2) User commands: the user types single-character commands
after positioning the cursor: the following are accepted:
  A (Add)    - add point at current cursor location.
  D (Delete) - delete last-entered point.
  X (eXit)   - leave subroutine.
\endtt}

\module{PGLDEV -- list available device types}
{\eightpoint\begintt
      SUBROUTINE PGLDEV
 
Writes a list to the terminal of all device types known to the
current version of PGPLOT.
 
Arguments: none.
\endtt}

\module{PGLEN -- Find length of a string in a variety of units}
{\eightpoint\begintt
      SUBROUTINE PGLEN (UNITS, STRING, XL, YL)
      REAL XL, YL
      INTEGER UNITS
      CHARACTER*(*) STRING
 
Work out length of a string in x and y directions 
 
Input
 UNITS    :  0 => answer in normalized device coordinates
             1 => answer in inches
             2 => answer in mm
             3 => answer in absolute device coordinates (dots)
             4 => answer in world coordinates
             5 => answer as a fraction of the current viewport size
 
 STRING   :  String of interest
Output
 XL       :  Length of string in x direction
 YL       :  Length of string in y direction
 
\endtt}

\module{PGLINE -- draw a polyline (curve defined by line-segments)}
{\eightpoint\begintt
      SUBROUTINE PGLINE (N, XPTS, YPTS)
      INTEGER  N
      REAL     XPTS(*), YPTS(*)
 
Primitive routine to draw a Polyline. A polyline is one or more
connected straight-line segments.  The polyline is drawn using
the current setting of attributes color-index, line-style, and
line-width. The polyline is clipped at the edge of the window.
 
Arguments:
 N      (input)  : number of points defining the line; the line
                   consists of (N-1) straight-line segments.
                   N should be greater than 1 (if it is 1 or less,
                   nothing will be drawn).
 XPTS   (input)  : world x-coordinates of the points.
 YPTS   (input)  : world y-coordinates of the points.
 
The dimension of arrays X and Y must be greater than or equal to N.
The "pen position" is changed to (X(N),Y(N)) in world coordinates
(if N > 1).
\endtt}

\module{PGMOVE -- move pen (change current pen position)}
{\eightpoint\begintt
      SUBROUTINE PGMOVE (X, Y)
      REAL X, Y
 
Primitive routine to move the "pen" to the point with world
coordinates (X,Y). No line is drawn.
 
Arguments:
 X      (input)  : world x-coordinate of the new pen position.
 Y      (input)  : world y-coordinate of the new pen position.
\endtt}

\module{PGMTEXT -- non-standard alias for PGMTXT}
{\eightpoint\begintt
      SUBROUTINE PGMTEXT (SIDE, DISP, COORD, FJUST, TEXT)
      CHARACTER*(*) SIDE, TEXT
      REAL DISP, COORD, FJUST
\endtt}

\module{PGMTXT -- write text at position relative to viewport}
{\eightpoint\begintt
      SUBROUTINE PGMTXT (SIDE, DISP, COORD, FJUST, TEXT)
      CHARACTER*(*) SIDE, TEXT
      REAL DISP, COORD, FJUST
 
Write text at a position specified relative to the viewport (outside
or inside).  This routine is useful for annotating graphs. It is used
by routine PGLAB.  The text is written using the current values of
attributes color-index, line-width, character-height, and
character-font.
 
Arguments:
 SIDE   (input)  : must include one of the characters 'B', 'L', 'T',
                   or 'R' signifying the Bottom, Left, Top, or Right
                   margin of the viewport. If it includes 'LV' or
                   'RV', the string is written perpendicular to the
                   frame rather than parallel to it.
 DISP   (input)  : the displacement of the character string from the
                   specified edge of the viewport, measured outwards
                   from the viewport in units of the character
                   height. Use a negative value to write inside the
                   viewport, a positive value to write outside.
 COORD  (input)  : the location of the character string along the
                   specified edge of the viewport, as a fraction of
                   the length of the edge.
 FJUST  (input)  : controls justification of the string parallel to
                   the specified edge of the viewport. If
                   FJUST = 0.0, the left-hand end of the string will
                   be placed at COORD; if JUST = 0.5, the center of
                   the string will be placed at COORD; if JUST = 1.0,
                   the right-hand end of the string will be placed at
                   at COORD. Other values between 0 and 1 give inter-
                   mediate placing, but they are not very useful.
 TEXT   (input) :  the text string to be plotted. Trailing spaces are
                   ignored when justifying the string, but leading
                   spaces are significant.
 
\endtt}

\module{PGNCUR -- mark a set of points using the cursor}
{\eightpoint\begintt
      SUBROUTINE PGNCUR (MAXPT, NPT, X, Y, SYMBOL)
      INTEGER MAXPT, NPT
      REAL    X(*), Y(*)
      INTEGER SYMBOL
 
Interactive routine for user to enter data points by use of
the cursor.  Routine allows user to Add and Delete points.  The
points are returned in order of increasing x-ccordinate, not in the
order they were entered.
 
Arguments:
 MAXPT  (input)  : maximum number of points that may be accepted.
 NPT    (in/out) : number of points entered; should be zero on
                   first call.
 X      (in/out) : array of x-coordinates.
 Y      (in/out) : array of y-coordinates.
 SYMBOL (input)  : code number of symbol to use for marking
                   entered points (see PGPT).
 
Note (1): The dimension of arrays X and Y must be greater than or
equal to MAXPT.
 
Note (2): On return from the program, cursor points are returned in
increasing order of X. Routine may be (re-)called with points
already defined in X,Y (number in NPT), and they will be plotted
first, before editing.
 
Note (3): User commands: the user types single-character commands
after positioning the cursor: the following are accepted:
A (Add)    - add point at current cursor location.
D (Delete) - delete nearest point to cursor.
X (eXit)   - leave subroutine.
\endtt}

\module{PGNCURSE -- non-standard alias for PGNCUR}
{\eightpoint\begintt
      SUBROUTINE PGNCURSE (MAXPT, NPT, X, Y, SYMBOL)
      INTEGER MAXPT, NPT
      REAL    X(*), Y(*)
      INTEGER SYMBOL
\endtt}

\module{PGNUMB -- convert a number into a plottable character string}
{\eightpoint\begintt
      SUBROUTINE PGNUMB (MM, PP, FORM, STRING, NC)
      INTEGER MM, PP, FORM
      CHARACTER*(*) STRING
      INTEGER NC
 
This routine converts a number into a decimal character
representation. To avoid problems of floating-point roundoff, the
number must be provided as an integer (MM) multiplied by a power of 10
(10**PP).  The output string retains only significant digits of MM,
and will be in either integer format (123), decimal format (0.0123),
or exponential format (1.23x10**5). Standard escape sequences \u, \d 
raise the exponent and \\ is used for the multiplication sign.
This routine is used by PGBOX to create numeric labels for a plot.
 
Formatting rules:
  (a) Decimal notation (FORM=1):
      - Trailing zeros to the right of the decimal sign are
        omitted
      - The decimal sign is omitted if there are no digits
        to the right of it
      - When the decimal sign is placed before the first digit
        of the number, a zero is placed before the decimal sign
      - The decimal sign is a period (.)
      - No spaces are placed between digits (ie digits are not
        grouped in threes as they should be)
      - A leading minus (-) is added if the number is negative
  (b) Exponential notation (FORM=2):
      - The exponent is adjusted to put just one (non-zero)
        digit before the decimal sign
      - The mantissa is formatted as in (a), unless its value is
        1 in which case it and the multiplication sign are omitted
      - If the power of 10 is not zero and the mantissa is not
        zero, an exponent of the form \\10\u[-]nnn is appended,
        where \\ is a multiplication sign (cross), \u is an escape
        sequence to raise the exponent, and as many digits nnn
        are used as needed
  (c) Automatic choice (FORM=0):
        Decimal notation is used if the absolute value of the
        number is less than 10000 or greater than or equal to
        0.01. Otherwise exponential notation is used.
 
Arguments:
 MM     (input)
 PP     (input)  : the value to be formatted is MM*10**PP.
 FORM   (input)  : controls how the number is formatted:
                   FORM = 0 -- use either decimal or exponential
                   FORM = 1 -- use decimal notation
                   FORM = 2 -- use exponential notation
 STRING (output) : the formatted character string, left justified.
                   If the length of STRING is insufficient, a single
                   asterisk is returned, and NC=1.
 NC     (output) : the number of characters used in STRING:
                   the string to be printed is STRING(1:NC).
\endtt}

\module{PGOLIN -- mark a set of points using the cursor}
{\eightpoint\begintt
      SUBROUTINE PGOLIN (MAXPT, NPT, X, Y, SYMBOL)
      INTEGER MAXPT, NPT
      REAL    X(*), Y(*)
      INTEGER SYMBOL
 
Interactive routine for user to enter data points by use of
the cursor.  Routine allows user to Add and Delete points.  The
points are returned in the order that they were entered (unlike
PGNCUR).
 
Arguments:
 MAXPT  (input)  : maximum number of points that may be accepted.
 NPT    (in/out) : number of points entered; should be zero on
                   first call.
 X      (in/out) : array of x-coordinates.
 Y      (in/out) : array of y-coordinates.
 SYMBOL (input)  : code number of symbol to use for marking
                   entered points (see PGPT).
 
Note (1): The dimension of arrays X and Y must be greater than or
equal to MAXPT.
 
Note (2): On return from the program, cursor points are returned in
the order they were entered. Routine may be (re-)called with points
already defined in X,Y (number in NPT), and they will be plotted
first, before editing.
 
Note (3): User commands: the user types single-character commands
after positioning the cursor: the following are accepted:
A (Add)    - add point at current cursor location.
D (Delete) - delete the last point entered.
X (eXit)   - leave subroutine.
\endtt}

\module{PGPAGE -- advance to new page}
{\eightpoint\begintt
      SUBROUTINE PGPAGE
 
Advance plotter to a new (sub-)page, clearing the screen if
necessary. If the "prompt state" is ON (see PGASK), confirmation is
requested from the user before clearing the screen.  For an
explanation of sub-pages, see PGBEG.  PGPAGE does not change the
window or the position of the viewport relative to the (sub-)page.
 
Arguments: none
\endtt}

\module{PGPAP -- change the size of the view surface ("paper size")}
{\eightpoint\begintt
      SUBROUTINE PGPAP (WIDTH, ASPECT)
      REAL WIDTH, ASPECT
 
This routine changes the size of the view surface to a specified
width and aspect ratio (height/width), in so far as this is possible
on the specific device. It is always possible to obtain a view
surface smaller than the default size; on some devices (e.g.,
printers that print on roll or fan-feed paper) it is possible
to obtain a view surface larger than the default. If this routine is
used, it must be called immediately after PGBEGIN.
 
Arguments:
 WIDTH  (input)  : the requested width of the view surface in inches;
                   if WIDTH=0.0, PGPAP will obtain the largest view
                   surface available consistent with argument ASPECT.
 ASPECT (input)  : the aspect ratio (height/width) of the view
                   surface; e.g., ASPECT=1.0 gives a square view
                   surface, ASPECT=0.618 gives a horizontal
                   rectangle, ASPECT=1.618 gives a vertical rectangle.
\endtt}

\module{PGPAPER -- non-standard alias for PGPAP}
{\eightpoint\begintt
      SUBROUTINE PGPAPER (WIDTH, ASPECT)
      REAL WIDTH, ASPECT
\endtt}

\module{PGPIXL -- draw pixels}
{\eightpoint\begintt
      SUBROUTINE PGPIXL (IA, IDIM, JDIM, I1, I2, J1, J2, 
     1                   X1, X2, Y1, Y2)
      INTEGER IDIM, JDIM, I1, I2, J1, J2
      INTEGER IA(IDIM,JDIM)
      REAL    X1, X2, Y1, Y2
 
Draw lots of solid-filled (tiny) rectangles alligned with the
coordinate axes. Best performance is achieved when output is
directed to a pixel-oriented device and the rectangles coincide
with the pixels on the device. In other cases, pixel output is
emulated.
 
The subsection of the array IA defined by indices (I1:I2, J1:J2)
is mapped onto world-coordinate rectangle defined by X1, X2, Y1
and Y2. This rectangle is divided int (I2 - I1 + 1) * (J2 - J1 + 1)
small rectangles. Each of these small rectangles is solid-filled
with the color index specified by the corresponding element of 
IA.
 
On most devices, the output region is "opaque", i.e., it obscures
all graphical elements previously drawn in the region. But on
devices that do not have erase capability, the background shade
is "transparent" and allows previously-drawn graphics to show
through.
 
 
Arguments:
 IA     (input)  : the array to be plotted.
 IDIM   (input)  : the first dimension of array A.
 JDIM   (input)  : the second dimension of array A.
 I1, I2 (input)  : the inclusive range of the first index
                   (I) to be plotted.
 J1, J2 (input)  : the inclusive range of the second
                   index (J) to be plotted.
 X1, Y1 (input)  : world coordinates of one corner of the output
                   region
 X2, Y2 (input)  : world coordinates of the opposite corner of the
                   output region
\endtt}

\module{PGPNTS -- draw one or more graph markers}
{\eightpoint\begintt
      SUBROUTINE PGPNTS (N, X, Y, SYMBOL, NS)
      INTEGER N, NS
      REAL X(*), Y(*)
      INTEGER SYMBOL(*)
 
Draw Graph Markers. Unlike PGPT, this routine can draw a different
symbol at each point. The markers
are drawn using the current values of attributes color-index,
line-width, and character-height (character-font applies if the symbol
number is >31).  If the point to be marked lies outside the window,
no marker is drawn.  The "pen position" is changed to
(XPTS(N),YPTS(N)) in world coordinates (if N > 0).
 
Arguments:
 N      (input)  : number of points to mark.
 X      (input)  : world x-coordinate of the points.
 Y      (input)  : world y-coordinate of the points.
 SYMBOL (input)  : code number of the symbol to be plotted at each
                   point (see PGPT).
 NS     (input)  : number of values in the SYMBOL array.  If NS <= N,
                   then the first NS points are drawn using the value
                   of SYMBOL(I) at (X(I), Y(I)) and SYMBOL(1) for all
                   the values of (X(I), Y(I)) where I > NS.
 
Note: the dimension of arrays X and Y must be greater than or equal
to N and the dimension of the array SYMBOL must be greater than or
equal to NS.  If N is 1, X and Y may be scalars (constants or
variables).  If NS is 1, then SYMBOL may be a scalar.  If N is
less than 1, nothing is drawn.
\endtt}

\module{PGPOINT -- non-standard alias for PGPT}
{\eightpoint\begintt
      SUBROUTINE PGPOINT (N, XPTS, YPTS, SYMBOL)
      INTEGER N
      REAL XPTS(*), YPTS(*)
      INTEGER SYMBOL
\endtt}

\module{PGPOLY -- fill a polygonal area with shading}
{\eightpoint\begintt
      SUBROUTINE PGPOLY (N, XPTS, YPTS)
      INTEGER N
      REAL XPTS(*), YPTS(*)
 
Fill-area primitive routine: shade the interior of a closed
polygon in the current window.  The action of this routine depends
on the setting of the Fill-Area Style attribute. If Fill-Area Style
is SOLID (the default), the interior of the polygon is solid-filled
using the current Color Index. If Fill-Area Style is HOLLOW, the
outline of the polygon is drwan using the current line attributes
(color index, line-style, and line-width). Other values of the Fill-
Area attribute may be allowed in future, e.g., for shading with
patterns or hatching. The polygon is clipped at the edge of the
window. The pen position is changed to (XPTS(1),YPTS(1)) in world
coordinates (if N > 1).  If the polygon is not convex, a point is
assumed to lie inside the polygon if a straight line drawn to
infinity intersects and odd number of the polygon's edges.
 
Arguments:
 N      (input)  : number of points defining the polygon; the
                   line consists of N straight-line segments,
                   joining points 1 to 2, 2 to 3,... N-1 to N, N to 1.
                   N should be greater than 2 (if it is 2 or less,
                   nothing will be drawn).
 XPTS   (input)  : world x-coordinates of the vertices.
 YPTS   (input)  : world y-coordinates of the vertices.
                   Note: the dimension of arrays XPTS and YPTS must be
                   greater than or equal to N.
\endtt}

\module{PGPT -- draw one or more graph markers}
{\eightpoint\begintt
      SUBROUTINE PGPT (N, XPTS, YPTS, SYMBOL)
      INTEGER N
      REAL XPTS(*), YPTS(*)
      INTEGER SYMBOL
 
Primitive routine to draw Graph Markers (polymarker). The markers
are drawn using the current values of attributes color-index,
line-width, and character-height (character-font applies if the symbol
number is >31).  If the point to be marked lies outside the window,
no marker is drawn.  The "pen position" is changed to
(XPTS(N),YPTS(N)) in world coordinates (if N > 0).
 
Arguments:
 N      (input)  : number of points to mark.
 XPTS   (input)  : world x-coordinates of the points.
 YPTS   (input)  : world y-coordinates of the points.
 SYMBOL (input)  : code number of the symbol to be drawn at each 
                   point:
                   -1, -2  : a single dot (diameter = current
                             line width).
                   -3..-31 : a regular polygon with ABS(SYMBOL)
                             edges (style set by current fill style).
                   0..31   : standard marker symbols.
                   32..127 : ASCII characters (in current font).
                             e.g. to use letter F as a marker, let
                             SYMBOL = ICHAR('F'). 
                   > 127  :  a Hershey symbol number.
 
Note: the dimension of arrays X and Y must be greater than or equal
to N. If N is 1, X and Y may be scalars (constants or variables). If
N is less than 1, nothing is drawn.
\endtt}

\module{PGPTEXT -- non-standard alias for PGPTXT}
{\eightpoint\begintt
      SUBROUTINE PGPTEXT (X, Y, ANGLE, FJUST, TEXT)
      REAL X, Y, ANGLE, FJUST
      CHARACTER*(*) TEXT
\endtt}

\module{PGPTXT -- write text at arbitrary position and angle}
{\eightpoint\begintt
      SUBROUTINE PGPTXT (X, Y, ANGLE, FJUST, TEXT)
      REAL X, Y, ANGLE, FJUST
      CHARACTER*(*) TEXT
 
Primitive routine for drawing text. The text may be drawn at any
angle with the horizontal, and may be centered or left- or right-
justified at a specified position.  Routine PGTEXT provides a
simple interface to PGPTXT for horizontal strings. Text is drawn
using the current values of attributes color-index, line-width,
character-height, and character-font.  Text is NOT subject to
clipping at the edge of the window.
 
Arguments:
 X      (input)  : world x-coordinate.
 Y      (input)  : world y-coordinate. The string is drawn with the
                   baseline of all the characters passing through
                   point (X,Y); the positioning of the string along
                   this line is controlled by argument FJUST.
 ANGLE  (input)  : angle, in degrees, that the baseline is to make
                   with the horizontal, increasing counter-clockwise
                   (0.0 is horizontal).
 FJUST  (input)  : controls horizontal justification of the string.
                   If FJUST = 0.0, the string will be left-justified
                   at the point (X,Y); if FJUST = 0.5, it will be
                   centered, and if FJUST = 1.0, it will be right
                   justified. [Other values of FJUST give other
                   justifications.]
 TEXT   (input)  : the character string to be plotted.
\endtt}

\module{PGQCF -- inquire character font}
{\eightpoint\begintt
      SUBROUTINE PGQCF (IF)
      INTEGER  IF
 
Query the current Character Font (set by routine PGSCF).
 
Argument:
 IF     (output)   : the current font number (in range 1-4).
\endtt}

\module{PGQCH -- inquire character height}
{\eightpoint\begintt
      SUBROUTINE PGQCH (SIZE)
      REAL SIZE
 
Query the Character Size attribute (set by routine PGSCH).
 
Argument:
 SIZE   (output) : current character size (dimensionless multiple of
                   the default size).
\endtt}

\module{PGQCI -- inquire color index}
{\eightpoint\begintt
      SUBROUTINE PGQCI (CI)
      INTEGER  CI
 
Query the Color Index attribute (set by routine PGSCI).
 
Argument:
 CI     (output) : the current color index (in range 0-max). This is
                   the color index actually in use, and may differ
                   from the color index last requested by PGSCI if
                   that index is not available on the output device.
\endtt}

\module{PGQCOL -- inquire color capability}
{\eightpoint\begintt
      SUBROUTINE PGQCOL (CI1, CI2)
      INTEGER  CI1, CI2
 
Query the range of color indices available on the current device.
 
Argument:
 CI1    (output) : the minimum available color index. This will be
                   either 0 if the device can write in the
                   background color, or 1 if not.
 CI2    (output) : the maximum available color index. This will be
                   1 if the device has no color capability, or a
                   larger number (e.g., 3, 7, 15, 255).
\endtt}

\module{PGQCR -- inquire color representation}
{\eightpoint\begintt
PGQCR: not yet available.
\endtt}

\module{PGQFS -- inquire fill-area style}
{\eightpoint\begintt
      SUBROUTINE PGQFS (FS)
      INTEGER  FS
 
Query the current Fill-Area Style attribute (set by routine
PGSFS).
 
Argument:
 FS     (output) : the current fill-area style:
                     FS = 1 => solid (default)
                     FS = 2 => hollow
\endtt}

\module{PGQINF -- inquire PGPLOT general information}
{\eightpoint\begintt
      SUBROUTINE PGQINF (ITEM, VALUE, LENGTH)
      CHARACTER*(*) ITEM, VALUE
      INTEGER LENGTH
 
This routine can be used to obtain miscellaneous information about
the PGPLOT environment. Input is a character string defining the
information required, and output is a character string containing the
requested information.
 
The following item codes are accepted (note that the strings must
match exactly, except for case, but only the first 8 characters are
significant). For items marked *, PGPLOT must be in the OPEN state
for the inquiry to succeed. If the inquiry is unsuccessful, either
because the item code is not recognized or because the information
is not available, a question mark ('?') is returned.
 
  'VERSION'     - version of PGPLOT software in use.
  'STATE'       - status of PGPLOT ('OPEN' if a graphics device
                  is open for output, 'CLOSED' otherwise).
  'USER'        - the username associated with the calling program.
  'NOW'         - current date and time (e.g., '17-FEB-1986 10:04').
  'DEVICE'    * - current PGPLOT device or file.
  'FILE'      * - current PGPLOT device or file.
  'TYPE'      * - device-type of the current PGPLOT device.
  'DEV/TYPE'  * - current PGPLOT device and type, in a form which
                  is acceptable as an argument for PGBEG.
  'HARDCOPY'  * - is the current device a hardcopy device? ('YES' or
                  'NO').
  'TERMINAL'  * - is the current device the user's interactive
                  terminal? ('YES' or 'NO').
  'CURSOR'    * - does the current device have a graphics cursor?
                  ('YES' or 'NO').
 
Arguments:
 ITEM  (input)  : character string defining the information to
                  be returned; see above for a list of possible
                  values.
 VALUE (output) : returns a character-string containing the
                  requested information.
 LENGTH (output): the number of characters returned in VALUE
                  (VALUE is padded with spaces to the length
                  supplied).
\endtt}

\module{PGQLS -- inquire line style}
{\eightpoint\begintt
      SUBROUTINE PGQLS (LS)
      INTEGER  LS
 
Query the current Line Style attribute (set by routine PGSLS).
 
Argument:
 LS     (output) : the current line-style attribute (in range 1-5).
\endtt}

\module{PGQLW -- inquire line width}
{\eightpoint\begintt
      SUBROUTINE PGQLW (LW)
      INTEGER  LW
 
Query the current Line-Width attribute (set by routine PGSLW).
 
Argument:
 LW     (output)  : the line-width (in range 1-21).
\endtt}

\module{PGQPOS -- inquire current pen position}
{\eightpoint\begintt
      SUBROUTINE PGQPOS (X, Y)
      REAL X, Y
 
Query the current "pen" position in world C coordinates (X,Y).
 
Arguments:
 X      (output)  : world x-coordinate of the pen position.
 Y      (output)  : world y-coordinate of the pen position.
\endtt}

\module{PGQVP -- inquire viewport size and position}
{\eightpoint\begintt
      SUBROUTINE PGQVP (UNITS, X1, X2, Y1, Y2)
      INTEGER UNITS
      REAL    X1, X2, Y1, Y2
 
Inquiry routine to determine the current viewport setting.
The values returned may be normalized device coordinates, inches, mm,
or pixels, depending on the value of the input parameter CFLAG.
 
Arguments:
 UNITS  (input)  : used to specify the units of the output parameters:
                   UNITS = 0 : normalized device coordinates
                   UNITS = 1 : inches
                   UNITS = 2 : millimeters
                   UNITS = 3 : pixels
                   Other values give an error message, and are
                   treated as 0.
 X1     (output) : the x-coordinate of the bottom left corner of the
                   viewport.
 X2     (output) : the x-coordinate of the top right corner of the
                   viewport.
 Y1     (output) : the y-coordinate of the bottom left corner of the
                   viewport.
 Y2     (output) : the y-coordinate of the top right corner of the
                   viewport.
\endtt}

\module{PGQWIN -- inquire window boundary coordinates}
{\eightpoint\begintt
      SUBROUTINE PGQWIN (X1, X2, Y1, Y2)
      REAL X1, X2, Y1, Y2
 
Inquiry routine to determine the current window setting.
The values returned are world coordinates.
 
Arguments:
 X1     (output) : the x-coordinate of the bottom left corner
                   of the window.
 X2     (output) : the x-coordinate of the top right corner
                   of the window.
 Y1     (output) : the y-coordinate of the bottom left corner
                   of the window.
 Y2     (output) : the y-coordinate of the top right corner
                   of the window.
\endtt}

\module{PGRECT -- draw a rectangle, using fill-area attributes}
{\eightpoint\begintt
      SUBROUTINE PGRECT (X1, X2, Y1, Y2)
      REAL X1, X2, Y1, Y2
 
This routine can be used instead of PGPOLY for the special case of
drawing a rectangle aligned with the coordinate axes; only two
vertices need be specified instead of four.  On most devices, it is
faster to use PGRECT than PGPOLY for drawing rectangles.  The
rectangle has vertices at (X1,Y1), (X1,Y2), (X2,Y2), and (X1,Y2).
 
Arguments:
 X1, X2 (input) : the horizontal range of the rectangle.
 Y1, Y2 (input) : the vertical range of the rectangle.
\endtt}

\module{PGRND -- find the smallest "round" number greater than x}
{\eightpoint\begintt
      REAL FUNCTION PGRND (X, NSUB)
      REAL X
      INTEGER NSUB
 
Rooutine to find the smallest "round" number larger than x, a
"round" number being 1, 2 or 5 times a power of 10. If X is negative,
PGRND(X) = -PGRND(ABS(X)). eg PGRND(8.7) = 10.0,
PGRND(-0.4) = -0.5.  If X is zero, the value returned is zero.
CThis routine is used by PGBOX for choosing  tick intervals.
 
Returns:
 PGRND         : the "round" number.
Arguments:
 X      (input)  : the number to be rounded.
 NSUB   (output) : a suitable number of subdivisions for
                   subdividing the "nice" number: 2 or 5.
\endtt}

\module{PGRNGE -- choose axis limits}
{\eightpoint\begintt
      SUBROUTINE PGRNGE (X1, X2, XLO, XHI)
      REAL X1, X2, XLO, XHI
 
Choose plotting limits XLO and XHI which encompass the data
range X1 to X2.
 
Arguments:
 X1, X2 (input)  : the data range (X1<X2), ie, the min and max values
                   to be plotted.
 XLO
 XHI    (output) : suitable values to use as the extremes of a graph
                   axis (XLO <= X1, XHI >= X2).
\endtt}

\module{PGSCF -- set character font}
{\eightpoint\begintt
      SUBROUTINE PGSCF (IF)
      INTEGER  IF
 
Set the Character Font for subsequent text plotting. Four different
fonts are available:
  1: (default) a simple single-stroke font ("normal" font)
  2: roman font
  3: italic font
  4: script font
This call determines which font is in effect at the beginning of
each text string. The font can be changed (temporarily) within a text
string by using the escape sequences \fn, \fr, \fi, and \fs for fonts
1, 2, 3, and 4, respectively.
 
Argument:
 IF     (input)  : the font number to be used for subsequent text
                   plotting (in range 1-4).
\endtt}

\module{PGSCH -- set character height}
{\eightpoint\begintt
      SUBROUTINE PGSCH (SIZE)
      REAL SIZE
 
Set the character size attribute. The size affects all text and graph
markers drawn later in the program. The default character size is
1.0, corresponding to a character height about 1/40 the height of
the view surface.  Changing the character size also scales the length
of tick marks drawn by PGBOX and terminals drawn by PGERRX and PGERRY.
 
Argument:
 SIZE   (input)  : new character size (dimensionless multiple of
                   the default size).
\endtt}

\module{PGSCI -- set color index}
{\eightpoint\begintt
      SUBROUTINE PGSCI (CI)
      INTEGER  CI
 
Set the Color Index for subsequent plotting, if the output device
permits this. The default color index is 1, usually white on a black
background for video displays or black on a white background for
printer plots. The color index is an integer in the range 0 to a
device-dependent maximum. Color index 0 corresponds to the background
color; lines may be "erased" by overwriting them with color index 0
(if the device permits this).
 
If the requested color index is not available on the selected device,
color index 1 will be substituted.
 
The assignment of colors to color indices can be changed with
subroutine PGSCR (set color representation).  Color indices 0-15
have predefined color representations (see the PGPLOT manual), but
these may be changed with PGSCR.  Color indices above 15  have no
predefined representations: if these indices are used, PGSCR must
be called to define the representation.
 
Argument:
 CI     (input)  : the color index to be used for subsequent plotting
                   on the current device (in range 0-max). If the
                   index exceeds the device-dependent maximum, the
                   default color index (1) is used.
\endtt}

\module{PGSCR -- set color representation}
{\eightpoint\begintt
      SUBROUTINE PGSCR (CI, CR, CG, CB)
      INTEGER CI
      REAL    CR, CG, CB
 
Set color representation: i.e., define the color to be
associated with a color index.  Ignored for devices which do not
support variable color or intensity.  Color indices 0-15
have predefined color representations (see the PGPLOT manual), but
these may be changed with PGSCR.  Color indices 16-maximum have no
predefined representations: if these indices are used, PGSCR must
be called to define the representation. On monochrome output
devices (e.g. VT125 terminals with monochrome monitors), the
monochrome intensity is computed from the specified Red, Green, Blue
intensities as 0.30*R + 0.59*G + 0.11*B, as in US color television
systems, NTSC encoding.  Note that most devices do not have an
infinite range of colors or monochrome intensities available;
the nearest available color is used.  Examples: for black,
set CR=CG=CB=0.0; for white, set CR=CG=CB=1.0; for medium gray,
set CR=CG=CB=0.5; for medium yellow, set CR=CG=0.5, CB=0.0.
 
Argument:
 CI     (input)  : the color index to be defined, in the range 0-max.
                   If the color index greater than the device
                   maximum is specified, the call is ignored. Color
                   index 0 applies to the background color.
 CR     (input)  : red, green, and blue intensities,
 CG     (input)    in range 0.0 to 1.0.
 CB     (input)
\endtt}

\module{PGSFS -- set fill-area style}
{\eightpoint\begintt
      SUBROUTINE PGSFS (FS)
      INTEGER  FS
 
Set the Fill-Area Style attribute for subsequent area-fill by
PGPOLY.  At present only two styles are available: solid (fill
polygon with solid color of the current color-index), and hollow
(draw outline of polygon only, using current line attributes).
 
Argument:
 FS     (input)  : the fill-area style to be used for subsequent
                   plotting:
                     FS = 1 => solid (default)
                     FS = 2 => hollow
                   Other values give an error message and are
                   treated as 2.
\endtt}

\module{PGSHLS -- set color representation using HLS system}
{\eightpoint\begintt
      SUBROUTINE PGSHLS (CI, CH, CL, CS)
      INTEGER CI
      REAL    CH, CL, CS
 
Set color representation: i.e., define the color to be
associated with a color index.  This routine is equivalent to
PGSCR, but the color is defined in the Hue-Lightness-Saturation
model instead of the Red-Green-Blue model.
 
Reference: SIGGRAPH Status Report of the Graphic Standards Planning
Committee, Computer Graphics, Vol.13, No.3, Association for
Computing Machinery, New York, NY, 1979.
 
Argument:
 CI     (input)  : the color index to be defined, in the range 0-max.
                   If the color index greater than the device
                   maximum is specified, the call is ignored. Color
                   index 0 applies to the background color.
 CH     (input)  : hue, in range 0.0 to 360.0.
 CL     (input)  : lightness, in range 0.0 to 1.0.
 CS     (input)  : saturation, in range 0.0 to 1.0.
\endtt}

\module{PGSLS -- set line style}
{\eightpoint\begintt
      SUBROUTINE PGSLS (LS)
      INTEGER  LS
 
Set the line style attribute for subsequent plotting. This
attribute affects line primitives only; it does not affect graph
markers, text, or area fill.
Five different line styles are available, with the following codes:
1 (full line), 2 (dashed), 3 (dot-dash-dot-dash), 4 (dotted),
5 (dash-dot-dot-dot). The default is 1 (normal full line).
 
Argument:
 LS     (input)  : the line-style code for subsequent plotting
                   (in range 1-5).
\endtt}

\module{PGSLW -- set line width}
{\eightpoint\begintt
      SUBROUTINE PGSLW (LW)
      INTEGER  LW
 
Set the line-width attribute. This attribute affects lines, graph
markers, and text. Thick lines are generated by tracing each line
with multiple strokes offset in the direction perpendicular to the
line. The line width is specified by the number of strokes to be
used, which must be in the range 1-201. The actual line width
obtained depends on the device resolution.
 
Argument:
 LW     (input)  : the number of strokes to be used
                   (in range 1-201).
\endtt}

\module{PGSVP -- set viewport (normalized device coordinates)}
{\eightpoint\begintt
      SUBROUTINE PGSVP (XLEFT, XRIGHT, YBOT, YTOP)
      REAL XLEFT, XRIGHT, YBOT, YTOP
 
Change the size and position of the viewport, specifying
the viewport in normalized device coordinates.  Normalized
device coordinates run from 0 to 1 in each dimension. The
viewport is the rectangle on the view surface "through"
which one views the graph.  All the PG routines which plot lines
etc. plot them within the viewport, and lines are truncated at
the edge of the viewport (except for axes, labels etc drawn with
PGBOX or PGLAB).  The region of world space (the coordinate
space of the graph) which is visible through the viewport is
specified by a call to PGSWIN.  It is legal to request a
viewport larger than the view surface; only the part which
appears on the view surface will be plotted.
 
Arguments:
 XLEFT  (input)  : x-coordinate of left hand edge of viewport, in NDC.
 XRIGHT (input)  : x-coordinate of right hand edge of viewport,
                   in NDC.
 YBOT   (input)  : y-coordinate of bottom edge of viewport, in NDC.
 YTOP   (input)  : y-coordinate of top  edge of viewport, in NDC.
\endtt}

\module{PGSWIN -- set window}
{\eightpoint\begintt
      SUBROUTINE PGSWIN (X1, X2, Y1, Y2)
      REAL X1, X2, Y1, Y2
 
Change the window in world coordinate space that is to be mapped on
to the viewport.  Usually PGSWIN is called automatically by PGENV,
but it may be called directly by the user.
 
Arguments:
 X1     (input)  : the x-coordinate of the bottom left corner
                   of the viewport.
 X2     (input)  : the x-coordinate of the top right corner
                   of the viewport (note X2 may be less than X1).
 Y1     (input)  : the y-coordinate of the bottom left corner
                   of the viewport.
 Y2     (input)  : the y-coordinate of the top right corner
                   of the viewport (note Y2 may be less than Y1).
\endtt}

\module{PGTBOX -- Draw a box and optionally write HH MM SS labelling.}
{\eightpoint\begintt
      SUBROUTINE PGTBOX (XOPT, XTICKD, NXSUBD, YOPT, YTICKD, NYSUBD)
 
      REAL XTICKD, YTICKD
      INTEGER NXSUBD, NYSUBD
      CHARACTER XOPT*(*), YOPT*(*)
 
Draw a box and optionally label one or both axes with HH MM SS style 
numeric labels (useful for time or RA - DEC plots). Should deal with 
axes that increase or decrease, and are positive or negative, or both.
If the HH MM SS labelling is desired, then PGSWIN should have been
previously called with the extrema in SECONDS.
 
Inputs:
 XOPT   :  X-options for PGBOX.  Same as for PGBOX plus 'Z' for time 
           labelling, and 'F' means write only the last part of the
           label for the first time tick on the axis.  E.g., if
           the full first label is 17 42 34.4 then write only 34.4
 YOPT   :  Y-options for PGBOX.  Same as for PGBOX plus 'Z' and 'F'
 XTICKD :  X-axis major tick increment.  Use 0.0 to get default. 
 YTICKD :  Y-axis major tick increment.  Use 0.0 to get default. 
 NXSUB  :  Number of intervals for minor ticks on X-axis. Use 0 for default
 NYSUB  :  Number of intervals for minor ticks on Y-axis. Use 0 for default
\endtt}

\module{PGTEXT -- write text (horizontal, left-justified)}
{\eightpoint\begintt
      SUBROUTINE PGTEXT (X, Y, TEXT)
      REAL X, Y
      CHARACTER*(*) TEXT
 
Write text. The bottom left corner of the first character is placed
at the specified position, and the text is written horizontally.
This is a simplified interface to the primitive routine PGPTXT.
For non-horizontal text, use PGPTXT.
 
Arguments:
 X      (input)  : world x-coordinate of start of string.
 Y      (input)  : world y-coordinate of start of string.
 TEXT   (input)  : the character string to be plotted.
\endtt}

\module{PGUPDT -- update display}
{\eightpoint\begintt
      SUBROUTINE PGUPDT
 
Update the graphics display: flush any pending commands to the
output device. This routine empties the buffer created by PGBBUF,
but it does not alter the PGBBUF/PGEBUF counter. The routine should
be called when it is essential that the display be completely up to
date (before interaction with the user, for example) but it is not
known if output is being buffered.
 
Arguments: none
\endtt}

\module{PGVPORT -- non-standard alias for PGSVP}
{\eightpoint\begintt
      SUBROUTINE PGVPORT (XLEFT, XRIGHT, YBOT, YTOP)
      REAL XLEFT, XRIGHT, YBOT, YTOP
\endtt}

\module{PGVSIZ -- set viewport (inches)}
{\eightpoint\begintt
      SUBROUTINE PGVSIZ (XLEFT, XRIGHT, YBOT, YTOP)
      REAL XLEFT, XRIGHT, YBOT, YTOP
 
Change the size and position of the viewport, specifying
the viewport in physical device coordinates (inches).  The
viewport is the rectangle on the view surface "through"
which one views the graph.  All the PG routines which plot lines
etc. plot them within the viewport, and lines are truncated at
the edge of the viewport (except for axes, labels etc drawn with
PGBOX or PGLAB).  The region of world space (the coordinate
space of the graph) which is visible through the viewport is
specified by a call to PGSWIN.  It is legal to request a
viewport larger than the view surface; only the part which
appears on the view surface will be plotted.
 
Arguments:
 XLEFT  (input)  : x-coordinate of left hand edge of viewport, in
                   inches from left edge of view surface.
 XRIGHT (input)  : x-coordinate of right hand edge of viewport, in
                   inches from left edge of view surface.
 YBOT   (input)  : y-coordinate of bottom edge of viewport, in
                   inches from bottom of view surface.
 YTOP   (input)  : y-coordinate of top  edge of viewport, in inches
                   from bottom of view surface.
\endtt}

\module{PGVSIZE -- non-standard alias for PGVSIZ}
{\eightpoint\begintt
      SUBROUTINE PGVSIZE (XLEFT, XRIGHT, YBOT, YTOP)
      REAL XLEFT, XRIGHT, YBOT, YTOP
\endtt}

\module{PGVSTAND -- non-standard alias for PGVSTD}
{\eightpoint\begintt
      SUBROUTINE PGVSTAND
\endtt}

\module{PGVSTD -- set standard (default) viewport}
{\eightpoint\begintt
      SUBROUTINE PGVSTD
 
Define the viewport to be the standard viewport.  The standard
viewport is the full area of the view surface (or subpage),
less a margin of 4 character heights all round for labelling.
It thus depends on the current character size, set by PGSCH.
 
Arguments: none.
\endtt}

\module{PGWINDOW -- non-standard alias for PGSWIN}
{\eightpoint\begintt
      SUBROUTINE PGWINDOW (X1, X2, Y1, Y2)
      REAL X1, X2, Y1, Y2
\endtt}

\module{PGWNAD -- set window and adjust viewport to same aspect ratio}
{\eightpoint\begintt
      SUBROUTINE PGWNAD (X1, X2, Y1, Y2)
      REAL X1, X2, Y1, Y2
 
Change the window in world coordinate space that is to be mapped on
to the viewport, and simultaneously adjust the viewport so that the
world-coordinate scales are equal in x and y. The new viewport is
the largest one that can fit within the previously set viewport
while retaining the required aspect ratio.
 
Arguments:
 X1     (input)  : the x-coordinate of the bottom left corner
                   of the viewport.
 X2     (input)  : the x-coordinate of the top right corner
                   of the viewport (note X2 may be less than X1).
 Y1     (input)  : the y-coordinate of the bottom left corner
                   of the viewport.
 Y2     (input)  : the y-coordinate of the top right corner of the
                   viewport (note Y2 may be less than Y1).
\endtt}
